#include <stdio.h>
#include <inttypes.h>
#include <stdlib.h>

#include "../cipher_utils.h"

#define CPU_DEVICE "CPU"
#define GPU_DEVICE "GPU"

#define KEYLEN 128

#define CLEFIA_128

#define DES3


void testFra(){
/*
	#if KEYLEN == 128
  	uint64_t Plaintext[2] = {0x0123456789abcdef, 0xfedcba9876543210};
  	uint64_t Ciphertext[16] = {0x6767313854966973, 0x0857065648eabe43, 0x6767313854966973, 0x0857065648eabe43, 0x6767313854966973, 0x0857065648eabe43, 0x6767313854966973, 0x0857065648eabe43, 0x6767313854966973, 0x0857065648eabe43, 0x6767313854966973, 0x0857065648eabe43, 0x6767313854966973, 0x0857065648eabe43, 0x6767313854966973, 0x0857065648eabe43};
  	uint64_t Key[2] = {0x0123456789abcdef, 0xfedcba9876543210};
	#elif KEYLEN == 192
  	uint64_t Plaintext[2] = {0x0123456789abcdef, 0xfedcba9876543210};
  	uint64_t Ciphertext[16] = {0xb4993401b3e996f8, 0x4ee5cee7d79b09b9, 0xb4993401b3e996f8, 0x4ee5cee7d79b09b9, 0xb4993401b3e996f8, 0x4ee5cee7d79b09b9, 0xb4993401b3e996f8, 0x4ee5cee7d79b09b9,
0xb4993401b3e996f8, 0x4ee5cee7d79b09b9, 0xb4993401b3e996f8, 0x4ee5cee7d79b09b9, 0xb4993401b3e996f8, 0x4ee5cee7d79b09b9, 0xb4993401b3e996f8, 0x4ee5cee7d79b09b9};
  	uint64_t Key[3] = {0x0123456789abcdef, 0xfedcba9876543210,
	             0x0011223344556677};
	#elif KEYLEN == 256
  	uint64_t Plaintext[2] = {0x0123456789abcdef, 0xfedcba9876543210};
  	uint64_t Ciphertext[16] = {0x9acc237dff16d76c, 0x20ef7c919e3a7509, 0x9acc237dff16d76c, 0x20ef7c919e3a7509, 0x9acc237dff16d76c, 0x20ef7c919e3a7509, 0x9acc237dff16d76c, 0x20ef7c919e3a7509, 0x9acc237dff16d76c, 0x20ef7c919e3a7509, 0x9acc237dff16d76c, 0x20ef7c919e3a7509, 0x9acc237dff16d76c, 0x20ef7c919e3a7509, 0x9acc237dff16d76c, 0x20ef7c919e3a7509};
  	uint64_t Key[4] = {0x0123456789abcdef, 0xfedcba9876543210,
	             0x0011223344556677, 0x8899aabbccddeeff};

	#endif


	 uint64_t* camelliaPlaintext = (uint64_t*)malloc(16*sizeof(uint64_t));
	 
	 camelliaCtr128Encrypt("camellia_plaintext", Key, camelliaPlaintext, 8, CPU_DEVICE);
	 for(int i=0; i < 16; i++){
	 	printf("%016llx\n", camelliaPlaintext[i]);
	 }

	for(int k = 0; k < 8; k++){
		if (camelliaPlaintext[2*k] != Ciphertext[2*k] || camelliaPlaintext[2*k+1] != Ciphertext[2*k+1]) {
			printf("no\n");
		}
	}
        printf("ok\n");

	free(camelliaPlaintext);*/

/*	uint8_t* clefiaPlaintext = (uint8_t*)malloc(128*sizeof(uint8_t));
	const unsigned char skey[32] = {
	    0xffU,0xeeU,0xddU,0xccU,0xbbU,0xaaU,0x99U,0x88U,
	    0x77U,0x66U,0x55U,0x44U,0x33U,0x22U,0x11U,0x00U,
	    0xf0U,0xe0U,0xd0U,0xc0U,0xb0U,0xa0U,0x90U,0x80U,
	    0x70U,0x60U,0x50U,0x40U,0x30U,0x20U,0x10U,0x00U
  	};
	#if defined (CLEFIA_128)
	  unsigned char ct[128] = {0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd, 0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd, 0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd, 0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd, 0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd, 0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd, 0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd, 0xde, 0x2b, 0xf2, 0xfd, 0x9b, 0x74, 0xaa, 0xcd, 0xf1, 0x29, 0x85, 0x55, 0x45, 0x94, 0x94, 0xfd};
	#elif defined (CLEFIA_192)
	  unsigned char ct[128] = {0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad, 0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad, 0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad, 0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad, 0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad, 0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad, 0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad, 0xe2, 0x48, 0x2f, 0x64, 0x9f, 0x02, 0x8d, 0xc4, 0x80, 0xdd, 0xa1, 0x84, 0xfd, 0xe1, 0x81, 0xad};
	#elif defined (CLEFIA_256)
	  unsigned char ct[128] = {0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a, 0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a, 0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a, 0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a, 0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a, 0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a, 0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a, 0xa1, 0x39, 0x78, 0x14, 0x28, 0x9d, 0xe8, 0x0c, 0x10, 0xda, 0x46, 0xd1, 0xfa, 0x48, 0xb3, 0x8a};
	#endif
	clefia_128_Encrypt("clefia_plaintext", skey, clefiaPlaintext, 1, CPU_DEVICE);
	for(int i=0; i < 128; i++){
	 	printf("%x", clefiaPlaintext[i]);
	 }
        if (memcmp(ct, clefiaPlaintext, 128) == 0) {
 	printf("\n--->[Test CORRECT]\n");
 	} else {
 	printf("\n--->[Test +WRONG!]\n");
 	}
	free(clefiaPlaintext);
	clefiaPlaintext = NULL;*/
/*
uint8_t* desPlaintext = (uint8_t*)malloc(8*sizeof(uint8_t));

	uint8_t DES3_keys[24] = {0x2B, 0xD6, 0x45, 0x9F, 0x82, 0xC5, 0xB3, 0x00, 0x95, 0x2C, 0x49, 0x10, 0x48, 0x81, 0xFF, 0x48, 0x2B, 0xD6, 0x45, 0x9F, 0x82, 0xC5, 0xB3, 0x00};

uint8_t DES3_init[8] = {0xEA, 0x02, 0x47, 0x14, 0xAD, 0x5C, 0x4D, 0x84};
#if defined (DES1)
uint8_t DES3_enc_test[8] = {0x12, 0x6E, 0xFE, 0x8E, 0xD3, 0x12, 0x19, 0x0A};
#elif defined (DES2)
uint8_t DES3_enc_test[8] = {0xC6, 0x16, 0xAC, 0xE8, 0x43, 0x95, 0x82, 0x47};
#elif defined (DES3)
uint8_t DES3_enc_test[8] = {0xC6, 0x16, 0xAC, 0xE8, 0x43, 0x95, 0x82, 0x47};
#endif
des3CtrEncrypt("des_plaintext", DES3_keys, desPlaintext, 1, CPU_DEVICE);
	for(int i=0; i < 8; i++){
	 	printf("%x", desPlaintext[i]);
	 }
        if (memcmp(DES3_enc_test, desPlaintext, 8) == 0) {
 	printf("\n--->[Test CORRECT]\n");
 	} else {
 	printf("\n--->[Test +WRONG!]\n");
 	}
	free(desPlaintext);
	desPlaintext = NULL;

*/
/*
uint64_t* desPlaintext = (uint64_t*)malloc(1*sizeof(uint64_t));

uint8_t Keys[16] = //{ 
    {0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
     0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00};
    //{0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
     //0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00}
  //};

  uint64_t Plaintexts[2] = {
    0x0000000000000000ul, 0x0011223344556677ul
  };

  uint64_t Ciphertexts[2] = {
    0x00f418aed94f03f2ul, 0x23ce9f72e543e6d8ul
  };

  // Key is supplied with byte 0 last
  hightEncrypt("hight_plaintext", Keys, desPlaintext, 1, CPU_DEVICE);
  for(int i = 0; i < 2; i++){
  	printf("%16llx\n", desPlaintext[i]);
  }
  if(desPlaintext[0] == Ciphertexts[0]){
  	printf("ok\n");
  } else printf("no\n");
*/
uint64_t* misty1Plaintext = (uint64_t*)malloc(2*sizeof(uint64_t));

uint8_t K[16] = {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
   };

  uint64_t P[2] = {
     0x0123456789abcdefUL,
    0xfedcba9876543210UL
  };

   uint64_t C[2] = {
     0x8b1da5f56ab3d07cUL,
     0x04b68240b13be95dUL
   };

  misty1Encrypt("misty1_plaintext", K, misty1Plaintext ,2, GPU_DEVICE);

  for(int i=0; i < 2; i++){
  	printf("%016llx\n", misty1Plaintext[i]);
  }
 
  if (misty1Plaintext[0] == C[0] && misty1Plaintext[1] == C[1]) {
    printf("ok\n");
  } else {
    printf("no\n");
  }
/*
uint64_t* presentPlaintext = (uint64_t*)malloc(1*sizeof(uint64_t));
  uint64_t Key3[2] = {0, 0};
  uint64_t ptx = 0; 
  uint64_t correct = 0x5579c1387b228445;

  present_memory_encrypt("present_plaintext", Key3, presentPlaintext, 1, GPU_DEVICE);
  for(int i=0; i < 1; i++){
  	printf("%016llx\n", presentPlaintext[i]);
  }

  if (presentPlaintext[0] == correct) {
   printf("ok\n");
  } else {
    printf("no\n");
  }
 
  free(presentPlaintext);

  present_memory_CtrEncrypt("present_plaintext", Key3, presentPlaintext, 1, GPU_DEVICE);
  for(int i=0; i < 1; i++){
  	printf("%016llx\n", presentPlaintext[i]);
  }

  if (presentPlaintext[0] == correct) {
    printf("ok\n");
  } else {
    printf("no\n");
  }
*/
  uint64_t* seedPlaintext = (uint64_t*)malloc(2*sizeof(uint64_t));
  uint32_t Key[4] = {0x00000000, 0x00000000, 0x00000000, 0x00000000};
  uint64_t Ciphertext[2] = { 0x5EBAC6E0054E1668ul, 0x19AFF1CC6D346CDBul};

  seed_old_Encrypt("seed_plaintext", Key, seedPlaintext, 1, GPU_DEVICE);
  for(int i=0; i < 2; i++){
  	printf("%016llx\n", seedPlaintext[i]);
  }

  if (seedPlaintext[0] == Ciphertext[0] && seedPlaintext[1] == Ciphertext[1]) {
    printf("ok\n");
  } else {
    printf("no\n");
  }

  seed_Encrypt("seed_plaintext", Key, seedPlaintext, 1, CPU_DEVICE);
  for(int i=0; i < 2; i++){
  	printf("%016llx\n", seedPlaintext[i]);
  }

  if (seedPlaintext[0] == Ciphertext[0] && seedPlaintext[1] == Ciphertext[1]) {
    printf("ok\n");
  } else {
    printf("no\n");
  }

  free(seedPlaintext);

//  free(output);
}
