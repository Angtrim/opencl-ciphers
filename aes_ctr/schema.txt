## aes.cl ##

// input: 1 blocco da 8 byte
// key: chiave
// output:  1 blocco da 8 byte cifrato
aesEncript(input, key, output){

 // Cifra input+ key e ritorna output con algoritmo AES

}

// input: 1 blocco da 8 byte cifrato
// key : chiave
// output:  1 blocco da 8 byte cifrato
aesDecript(inputCifrato, key, output){

 // Decifra input+ key e ritorna output con algoritmo AES

}

##


## aesCtr.cl ##

// input : 1000 blocchi da 8byte
// output : 1000 blocchi da 8byte
aesCtrEncript(input,key,nonce,output){
 
    prende la chiave e il nonce
    prende l'ennesimo blocco 
    prende il counter
    crea il nuovo input con nonce e counter -> newInput
    chiama aesEncript() (che è inclusa come header o una cosa così)

    counterOutput = NULL;
    aesEncript(newInput,key,counterOutput);
    output[get_global_id(0)] = counterOutput XOR input[get_global_id(0)]
}

// Uguale all'encript ma al contrario chiama la funzione aesDecript invece che la aesEncript
aesCtrDecript()...

##

## aesCtr.c ##


// file: file da encriptare
// key: chiave
// output: file criptato
aesCtrEncript(file,key,output){
 
   prende il file e lo divide in blocchi da 8 byte
   builda il file aesCtr.cl passandogli i blocchi 
   ritorna tutto criptato

}

##

## testProgram.c ##

// testo se vanno i cifrari

input = inputConosciuto;
outputCorretto;
key;

chiamo aesEncript() e controllo l'output se è corretto
chiame cameliaEncript() e controllo l'output se è corretto


// testo le performances

chiamo aesCtrEncript() con un file piccolo e vedo quanto ci mette
chiamo aesCtrEncript() con un file medio e vedo quanto ci mette
chiamo aesCtrEncript() con un file grande e vedo quanto ci mette









